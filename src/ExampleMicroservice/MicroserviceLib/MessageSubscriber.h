#pragma once

#include <functional>
#include <google/protobuf/message.h>
#include <memory>
#include <thread>
#include <type_traits>

#include "Logger.h"
#include "Subscriber.h"
#include "IMessageSubscriber.h"
#include "SafeQueue.h"

template <class T>
class MessageSubscriber : public IMessageSubscriber
{
	static_assert(std::is_base_of<google::protobuf::Message, T>::value, "T must be a subclass of google::protobuf::Message (in other words, it must be a class generated by protoc)");

public:

	MessageSubscriber() noexcept
	{
		m_consumeThread = std::thread{ &MessageSubscriber::ConsumeThreadMain, this };
	};

	~MessageSubscriber() {};

	using SubscribeCallback = std::function<void(std::shared_ptr<T> msg)>;

	void onMessage(SubscribeCallback subCallback)
	{
		m_subscribeCallback = subCallback;
		DeserializedMessage message = std::make_shared<T>();
		Subscriber::registerSubscriber(message->GetTypeName(), this);
		message.reset();
	}

	// Deserialize the message, and pass it on to the subscriber
	DeserializedMessage processSubscription(std::string encodedMsg) override
	{
		DeserializedMessage msg = std::make_shared<T>();
		const auto success = msg->ParseFromString(encodedMsg);
		if (!success)
		{
			Logger::error(__FILELINE__, "Could not deserialize: " + msg->GetTypeName());
		}
		m_messageQueue.enqueue(std::dynamic_pointer_cast<T>(msg));
		return msg;
	}

	// The Message has already been deserialized, but we want to pass it to a subscriber
	void processSubscription(DeserializedMessage msg) override
	{
		m_messageQueue.enqueue(std::dynamic_pointer_cast<T>(msg));
	}

private:

	void ConsumeThreadMain()
	{
		while (true)
		{
			auto msg = m_messageQueue.dequeue();
			m_subscribeCallback(msg);
		}
	}

	SubscribeCallback              m_subscribeCallback;
	SafeQueue<std::shared_ptr<T>>  m_messageQueue;
	std::thread                    m_consumeThread;
};