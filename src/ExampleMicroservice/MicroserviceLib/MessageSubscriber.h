#pragma once

#include <functional>
#include <google/protobuf/message.h>
#include <memory>
#include <thread>
#include <type_traits>

#include "Logger.h"
#include "Subscriber.h"
#include "IMessageSubscriber.h"
#include "SafeQueue.h"

template <class T>
class MessageSubscriber : public IMessageSubscriber
{
	static_assert(std::is_base_of<google::protobuf::Message, T>::value, "T must be a subclass of google::protobuf::Message (in other words, it must be a class generated by protoc)");

public:

	using SubscribeCallback = std::function<void(std::shared_ptr<T> msg)>;

	MessageSubscriber() noexcept
		: m_consumeThread(std::thread{ &MessageSubscriber::ConsumeThreadMain, this })
		, m_enabled(true)
		, m_messageQueue()
	{};

	~MessageSubscriber() 
	{
		DeserializedMessage message = std::make_shared<T>();
		Subscriber::unregisterSubscriber(message->GetTypeName(), this);
		message.reset();
		m_enabled = false;
		m_consumeThread.join();
	};

	bool onMessage(SubscribeCallback subCallback)
	{
		m_subscribeCallback = subCallback;
		DeserializedMessage message = std::make_shared<T>();
		auto registered = Subscriber::registerSubscriber(message->GetTypeName(), this);		
		if (!registered)
		{
			Logger::error(__FILELINE__, "Failed to register MessageSubscriber: " + message->GetTypeName());
		}
		message.reset();
		return registered;
	}

	// Deserialize the message, and pass it on to the subscriber
	DeserializedMessage processSubscription(std::string encodedMsg) override
	{
		DeserializedMessage msg = std::make_shared<T>();
		const auto success = msg->ParseFromString(encodedMsg);
		if (!success)
		{
			Logger::error(__FILELINE__, "Could not deserialize: " + msg->GetTypeName());
		}
		m_messageQueue.enqueue(std::dynamic_pointer_cast<T>(msg));
		return msg;
	}

	// The Message has already been deserialized, but we want to pass it to a subscriber
	void processSubscription(DeserializedMessage msg) override
	{
		m_messageQueue.enqueue(std::dynamic_pointer_cast<T>(msg));
	}

private:

	void ConsumeThreadMain()
	{
		while (m_enabled)
		{
			auto msg = m_messageQueue.dequeue();
			m_subscribeCallback(msg);
		}
	}

	std::thread                   m_consumeThread;
	std::atomic<bool>             m_enabled;
	SafeQueue<std::shared_ptr<T>> m_messageQueue;
	SubscribeCallback             m_subscribeCallback;
};